{"samples": [{"description": "    \"\"\"Parse a string or file-like object into a tree\"\"\"\n", "documentation": {"treebuilders.getTreeBuilder": "Get a TreeBuilder class for various types of tree with built-in support\n\n    treeType - the name of the tree type required (case-insensitive). Supported\n               values are:\n\n               \"dom\" - A generic builder for DOM implementations, defaulting to\n                       a xml.dom.minidom based implementation.\n               \"etree\" - A generic builder for tree implementations exposing an\n                         ElementTree-like interface, defaulting to\n                         xml.etree.cElementTree if available and\n                         xml.etree.ElementTree if not.\n               \"lxml\" - A etree-based builder for lxml.etree, handling\n                        limitations of lxml's implementation.\n\n    implementation - (Currently applies to the \"etree\" and \"dom\" tree types). A\n                      module implementing the tree type e.g.\n                      xml.etree.ElementTree or xml.etree.cElementTree.", "parse": "Parse a HTML document into a well-formed tree", "HTMLParser": "HTML parser. Generates a tree structure from a stream of (possibly\n        malformed) HTML"}, "filename": "html5lib/html5parser.py", "related_lines": {"7,53": [2]}, "snippet_lines": ["    tb = treebuilders.getTreeBuilder(treebuilder)\n", "    p = HTMLParser(tb, namespaceHTMLElements=namespaceHTMLElements)\n", "    return p.parse(doc, **kwargs)\n"], "start_line": 33}, {"description": "        \"\"\"Attempts to detect at BOM at the start of the stream. If\n        an encoding can be determined from the BOM return the name of the\n        encoding otherwise return None\"\"\"\n", "documentation": {"lookupEncoding": "Return the python codec name corresponding to an encoding or None if the\n    string doesn't correspond to a valid encoding."}, "filename": "html5lib/_inputstream.py", "related_lines": {"159,180": [26, 28], "11,63": [11, 13, 15, 17, 18], "65,158": [23, 25]}, "snippet_lines": ["        bomDict = {\n", "            codecs.BOM_UTF8: 'utf-8',\n", "            codecs.BOM_UTF16_LE: 'utf-16le', codecs.BOM_UTF16_BE: 'utf-16be',\n", "            codecs.BOM_UTF32_LE: 'utf-32le', codecs.BOM_UTF32_BE: 'utf-32be'\n", "        }\n", "\n", "        # Go to beginning of file and read in 4 bytes\n", "        string = self.rawStream.read(4)\n", "        assert isinstance(string, bytes)\n", "\n", "        # Try detecting the BOM using bytes from the string\n", "        encoding = bomDict.get(string[:3])         # UTF-8\n", "        seek = 3\n", "        if not encoding:\n", "            # Need to detect UTF-32 before UTF-16\n", "            encoding = bomDict.get(string)         # UTF-32\n", "            seek = 4\n", "            if not encoding:\n", "                encoding = bomDict.get(string[:2])  # UTF-16\n", "                seek = 2\n", "\n", "        # Set the read position past the BOM if one was found, otherwise\n", "        # set it to the start of the stream\n", "        if encoding:\n", "            self.rawStream.seek(seek)\n", "            return lookupEncoding(encoding)\n", "        else:\n", "            self.rawStream.seek(0)\n", "            return None\n"], "start_line": 539}, {"description": "        \"\"\"Look for a sequence of bytes at the start of a string. If the bytes\n        are found return True and advance the position to the byte after the\n        match. Otherwise return False and leave the position alone\"\"\"\n", "documentation": {}, "filename": "html5lib/_inputstream.py", "related_lines": {"11,64": [2], "113,169": [4]}, "snippet_lines": ["        p = self.position\n", "        data = self[p:p + len(bytes)]\n", "        rv = data.startswith(bytes)\n", "        if rv:\n", "            self.position += len(bytes)\n", "        return rv\n"], "start_line": 667}, {"description": "        \"\"\"Look for the next sequence of bytes matching a given sequence. If\n        a match is found advance the position to the last byte of the match\"\"\"\n", "documentation": {}, "filename": "html5lib/_inputstream.py", "related_lines": {"11,72": [0], "74,152": [1, 5]}, "snippet_lines": ["        newPosition = self[self.position:].find(bytes)\n", "        if newPosition > -1:\n", "            # XXX: This is ugly, but I can't see a nicer way to fix this.\n", "            if self._position == -1:\n", "                self._position = 0\n", "            self._position += (newPosition + len(bytes) - 1)\n", "            return True\n", "        else:\n", "            raise StopIteration\n"], "start_line": 677}], "commit_hash": "a3022dcea691780d300547bbf68b4dd921995d1c", "repo_url": "https://github.com/html5lib/html5lib-python"}