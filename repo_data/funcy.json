{"repo_url": "https://github.com/Suor/funcy", "commit_hash": "00863de7a8c5be2ac6503493e01f0b0281bab128", "samples": [{"description": "    Consume an iterable not reading it into memory; return the number of items.\n", "documentation": {"count": "count(start=0, step=1) --> count object\n\nReturn a count object whose .next() method returns consecutive values.\nEquivalent to:\n\n    def count(firstval=0, step=1):\n        x = firstval\n        while 1:\n            yield x\n            x += step\n", "deque": "deque([iterable[, maxlen]]) --> deque object\n\nBuild an ordered collection with optimized access from its endpoints.", "izip": "izip(iter1 [,iter2 [...]]) --> izip object\n\nReturn a izip object whose .next() method returns a tuple where\nthe i-th element comes from the i-th iterable argument.  The .next()\nmethod continues until the shortest iterable in the argument sequence\nis exhausted and then it raises StopIteration.  Works like the zip()\nfunction but consumes less memory by returning an iterator instead of\na list.", "next": "Retrieve the next item from the iterator by calling its next() method. If default is given, it is returned if the iterator is exhausted, otherwise StopIteration is raised."}, "filename": "funcy/seqs.py", "related_lines": {"4,50": [1], "52,78": [2]}, "snippet_lines": ["    counter = count()\n", "    deque(izip(seq, counter), maxlen=0)  # (consume at C speed)\n", "    return next(counter)\n"], "start_line": 91}, {"description": "    Walk coll transforming it's elements with f.\n\n    Same as map, but preserves coll type.\n", "documentation": {"iteritems": "Return an iterator over the dictionary\u2019s (key, value) pairs. See the note for dict.items(). Using iteritems() while adding or deleting entries in the dictionary may raise a RuntimeError or fail to iterate over all entries."}, "filename": "funcy/colls.py", "related_lines": {"4,90": [0]}, "snippet_lines": ["    return _factory(coll)(ximap(f, iteritems(coll)))\n"], "start_line": 117}, {"description": "    A functools.partial alternative, which returns a real function.\n\n    Can be used to construct methods.\n", "documentation": {}, "filename": "funcy/simple_funcs.py", "related_lines": {"37,66": [0]}, "snippet_lines": ["    return lambda *a, **kw: func(*(args + a), **dict(kwargs, **kw))\n"], "start_line": 28}, {"description": "            \"\"\"Return a recreated instance of self.\n\n\n\n            Allows an otherwise one-shot context manager like\n\n            _GeneratorContextManager to support use as\n\n            a decorator via implicit recreation.\n\n\n\n            This is a private interface just for _GeneratorContextManager.\n\n            See issue #11647 for details.\n", "documentation": {}, "filename": "funcy/decorators.py", "related_lines": {"15,50": [0]}, "snippet_lines": ["            return self\n"], "start_line": 106}, {"description": "        Get the object wrapped by ``func``.\n\n\n\n        Follows the chain of :attr:`__wrapped__` attributes returning the last\n\n        object in the chain.\n", "documentation": {"add": "add element x to set s", "set": "Return a new set object, optionally with elements taken from iterable. set is a built-in class.", "id": "Return the \u201cidentity\u201d of an object. This is an integer (or long integer) which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value.", "hasattr": "The arguments are an object and a string. The result is True if the string is the name of one of the object\u2019s attributes, False if not. (This is implemented by calling getattr(object, name) and seeing whether it raises an exception or not.)"}, "filename": "funcy/decorators.py", "related_lines": {"55,155": [2, 3, 8], "8,42": [2, 3, 8]}, "snippet_lines": ["        f = func  # remember the original func for error reporting\n", "        memo = set([id(f)]) # Memoise by id to tolerate non-hashable objects\n", "        while hasattr(func, '__wrapped__'):\n", "            func = func.__wrapped__\n", "            id_func = id(func)\n", "            if id_func in memo:\n", "                raise ValueError('wrapper loop when unwrapping {!r}'.format(f))\n", "            memo.add(id_func)\n", "        return func\n"], "start_line": 276}]}