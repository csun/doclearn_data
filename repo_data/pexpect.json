{"repo_url": "https://github.com/pexpect/pexpect", "commit_hash": "cb2f06f07d5a8dcd28f2d403a3a8f0845eae9861", "samples": [{"description": "        '''This searches 'buffer' for the first occurence of one of the search\n        strings.  'freshlen' must indicate the number of bytes at the end of\n        'buffer' which have not been searched before. It helps to avoid\n        searching the same, possibly big, buffer over and over again.\n\n        See class spawn for the 'searchwindowsize' argument.\n\n        If there is a match this returns the index of that string, and sets\n        'start', 'end' and 'match'. Otherwise, this returns -1. '''\n", "documentation": {}, "filename": "pexpect/expect.py", "related_lines": {"432,471": [28, 29, 30], "473,499": [26, 27], "369,426": [31]}, "snippet_lines": ["        first_match = None\n", "\n", "        # 'freshlen' helps a lot here. Further optimizations could\n", "        # possibly include:\n", "        #\n", "        # using something like the Boyer-Moore Fast String Searching\n", "        # Algorithm; pre-compiling the search through a list of\n", "        # strings into something that can scan the input once to\n", "        # search for all N strings; realize that if we search for\n", "        # ['bar', 'baz'] and the input is '...foo' we need not bother\n", "        # rescanning until we've read three more bytes.\n", "        #\n", "        # Sadly, I don't know enough about this interesting topic. /grahn\n", "\n", "        for index, s in self._strings:\n", "            if searchwindowsize is None:\n", "                # the match, if any, can only be in the fresh data,\n", "                # or at the very end of the old data\n", "                offset = -(freshlen + len(s))\n", "            else:\n", "                # better obey searchwindowsize\n", "                offset = -searchwindowsize\n", "            n = buffer.find(s, offset)\n", "            if n >= 0 and (first_match is None or n < first_match):\n", "                first_match = n\n", "                best_index, best_match = index, s\n", "        if first_match is None:\n", "            return -1\n", "        self.match = best_match\n", "        self.start = first_match\n", "        self.end = self.start + len(self.match)\n", "        return best_index\n"], "start_line": 174}, {"description": "        '''This calls write() for each element in the sequence.\n\n        The sequence can be any iterable object producing strings, typically a\n        list of strings. This does not add line separators. There is no return\n        value.\n", "documentation": {"send": "send data to the subprocess' stdin. Returns the number of bytes written."}, "filename": "pexpect/popen_spawn.py", "related_lines": {"11,62": [0, 1]}, "snippet_lines": ["        for s in sequence:\n", "            self.send(s)\n"], "start_line": 120}, {"description": "        '''Wait for the subprocess to finish.\n        \n        Returns the exit code.\n", "documentation": {}, "filename": "pexpect/popen_spawn.py", "related_lines": {"63,84": [8], "11,44": [0]}, "snippet_lines": ["        status = self.proc.wait()\n", "        if status >= 0:\n", "            self.exitstatus = status\n", "            self.signalstatus = None\n", "        else:\n", "            self.exitstatus = None\n", "            self.signalstatus = -status\n", "        self.terminated = True\n", "        return status\n"], "start_line": 152}, {"description": "        '''Closes the stdin pipe from the writing end.'''\n", "documentation": {}, "filename": "pexpect/popen_spawn.py", "related_lines": {"11,32": [0]}, "snippet_lines": ["        self.proc.stdin.close()\n"], "start_line": 179}]}