{"repo_url": "asd/schedule", "commit_hash": "9a37002ef7721138be4ce13dd94a87a438345b86", "samples": [{"description": "        \"\"\"Run all jobs that are scheduled to run.\n\n\n\n        Please note that it is *intended behavior that tick() does not\n\n        run missed jobs*. For example, if you've registered a job that\n\n        should run every minute and you only call tick() in one hour\n\n        increments then your job won't be run 60 times in between but\n\n        only once.\n", "documentation": {"should_run": "True if the job should be run now", "job.should_run": "true if the job should be run now", "sorted": "Return a new sorted list from the items in iterable."}, "filename": "schedule/__init__.py", "related_lines": {"11,49": [1, 2]}, "snippet_lines": ["        runnable_jobs = (job for job in self.jobs if job.should_run)\n", "        for job in sorted(runnable_jobs):\n", "            self._run_job(job)\n"], "start_line": 62}, {"description": "        \"\"\"Run all jobs regardless if they are scheduled to run or not.\n\n\n\n        A delay of `delay` seconds is added between each job. This helps\n\n        distribute system load generated by the jobs more evenly\n\n        over time.\"\"\"\n", "documentation": {"": "logger.info,time.sleep", "logger.info": "\n        Log 'msg % args' with severity 'INFO'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1)\n        ", "time.sleep": "sleep(seconds)\n\nDelay execution for a given number of seconds.  The argument may be\na floating point number for subsecond precision."}, "filename": "schedule/__init__.py", "related_lines": {"83,135": [4], "11,70": [2, 3]}, "snippet_lines": ["        logger.info('Running *all* %i jobs with %is delay inbetween',\n", "                    len(self.jobs), delay_seconds)\n", "        for job in self.jobs:\n", "            self._run_job(job)\n", "            time.sleep(delay_seconds)\n"], "start_line": 72}, {"description": "        \"\"\"Deletes all scheduled jobs.\"\"\"\n", "documentation": {}, "filename": "schedule/__init__.py", "related_lines": {"11,37": [0]}, "snippet_lines": ["        del self.jobs[:]\n"], "start_line": 80}, {"description": "        \"\"\"Delete a scheduled job.\"\"\"\n", "documentation": {"remove": "Remove the first occurrence of x from the array."}, "filename": "schedule/__init__.py", "related_lines": {"11,33": [1]}, "snippet_lines": ["        try:\n", "            self.jobs.remove(job)\n", "        except ValueError:\n", "            pass\n"], "start_line": 84}, {"description": "        \"\"\"Schedule the job every day at a specific time.\n\n\n\n        Calling this is only valid for jobs scheduled to run every\n\n        N day(s).\n", "documentation": {"self.start_day": "Specific day of the week to start on", "self.unit": "time units, e.g. 'minutes', 'hours', ..."}, "filename": "schedule/__init__.py", "related_lines": {"11,56": [9]}, "snippet_lines": ["        assert self.unit in ('days', 'hours') or self.start_day\n", "        hour, minute = time_str.split(':')\n", "        minute = int(minute)\n", "        if self.unit == 'days' or self.start_day:\n", "            hour = int(hour)\n", "            assert 0 <= hour <= 23\n", "        elif self.unit == 'hours':\n", "            hour = 0\n", "        assert 0 <= minute <= 59\n", "        self.at_time = datetime.time(hour, minute)\n", "        return self\n"], "start_line": 255}]}